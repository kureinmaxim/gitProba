#stm  #interrupt
[[STM]]

Чтобы правильно обработать прерывание, нужно:

1. **Настроить NVIC и включить нужные прерывания:**
- Разрешить прерывание в NVIC (`nvic_enable_irq`).
- Настроить конкретное периферийное устройство, чтобы оно генерировало прерывания (`usart_enable_rx_interrupt` в случае UART).
2. **Создать функцию-обработчик прерывания:**  
   Имя этой функции фиксировано и должно соответствовать таблице вектора прерываний для конкретного микроконтроллера (например, для STM32 это будет `USART1_IRQHandler`).

### `nvic_enable_irq(NVIC_USART1_IRQ);`

Эта функция разрешает прерывания на уровне NVIC (Nested Vectored Interrupt Controller).

- `NVIC_USART1_IRQ` — это предопределенное имя линии прерывания для периферии USART1.
- После выполнения этой функции контроллер NVIC готов принимать и обрабатывать запросы прерываний от USART1.

###  `usart_enable_rx_interrupt(USART1);`

Эта функция разрешает прерывания по приему данных для конкретного устройства `USART1`.

- В регистре управления USART (`CR1`) устанавливается соответствующий бит (обычно это `RXNEIE`, который отвечает за прерывания по событию "прием данных завершен").
- Когда данные поступают в приемный буфер USART1, устанавливается флаг RXNE (Receive Data Register Not Empty), который вызывает прерывание.


Обычно **запрещать другие прерывания в обработчике не нужно**, но всё зависит от конкретного сценария и требований к системе реального времени.
### ==Когда **не нужно** запрещать прерывания:==

- Если прерывания короткие и обрабатываются быстро.
- Если допустима вложенная обработка других прерываний.
- Когда нет критичных секций кода, где данные могут быть повреждены из-за прерываний.

### Когда **может понадобиться** запрещать прерывания:

3. **Критические секции:**  Если в обработчике прерываний происходит работа с общими ресурсами(например, запись в буферы), и одновременный вызов другого прерывания может повредить данные.
   
```c 
    __disable_irq(); // Отключаем глобальные прерывания 
    // Работа с критическими данными 
    __enable_irq(); // Включаем прерывания обратно
```

4. **Длинные обработчики:**  
   Если обработчик слишком длинный и другие важные события могут потеряться, стоит минимизировать время нахождения в обработчике.
   
5. **Прерывания с разным приоритетом:**  
   Если некоторые прерывания критичны и должны выполняться немедленно, можно правильно настроить приоритеты прерываний вместо полного их запрета.  

### Альтернатива — настройка приоритетов

Вместо полного отключения можно использовать функции типа `nvic_set_priority()` для назначения более низкого приоритета менее важных прерываний.

### Пример безопасного короткого обработчика:
```c
void USART1_IRQHandler(void) {
if (usart_get_flag(USART1, USART_FLAG_RXNE)) {
uint8_t data = usart_recv(USART1); 
process_data(data); // Быстрая обработка или помещение в буфер } }
```


==Итог: **не запрещайте прерывания без крайней необходимости**, лучше минимизируйте время выполнения кода и грамотно управляйте приоритетами.==