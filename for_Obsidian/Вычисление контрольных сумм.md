[[Python proxyCrypto]]
#checksums

Для вычисления контрольных сумм (checksums) в данной системе используется алгоритм SHA-256 (Secure Hash Algorithm 256-bit), который реализован через стандартную библиотеку Python hashlib.

В функции calculate_checksum из модуля utils.py вычисление контрольной суммы происходит следующим образом:

1. Создается объект хеша SHA-256
2. К нему добавляются данные (байты файла или чанка)
3. Возвращается шестнадцатеричное представление хеш-значения

Примерно такой код:
```python
def calculate_checksum(data):
    """Вычисляет SHA-256 хеш для данных"""
    hash_obj = hashlib.sha256(data)
    return hash_obj.hexdigest()
```
Функция verify_checksum просто сравнивает результат calculate_checksum с предоставленной контрольной суммой:
```python
def verify_checksum(data, checksum):
    """Проверяет совпадение контрольной суммы"""
    return calculate_checksum(data) == checksum
```

SHA-256 имеет следующие особенности:

1. Генерирует 256-битное (32-байтное) значение хеша, представленное как 64 шестнадцатеричных символа
2. Это криптографический хеш-алгоритм, устойчивый к коллизиям (практически невозможно найти два разных файла с одинаковым хешем)
3. Даже небольшое изменение в исходных данных приводит к значительному изменению хеша (лавинный эффект)

При передаче файла по сети:

1. Отправитель вычисляет SHA-256 хеш для каждого чанка данных
2. Отправляет этот хеш вместе с данными
3. Получатель вычисляет SHA-256 хеш полученных данных и сравнивает с полученным хешем
4. Если хеши совпадают, данные переданы без искажений

Этот механизм обеспечивает высокую степень уверенности в целостности переданных данных, так как вероятность случайного изменения данных, которое даст тот же SHA-256 хеш, практически равна нулю.
в системе хеш (контрольная сумма) отправляется вместе с данными, но как отдельное поле в JSON-объекте. Это происходит следующим образом:

## Процесс передачи чанка данных с контрольной суммой:

1. Подготовка чанка для отправки:
``` python
   # Вычисление контрольной суммы для чанка
   chunk_checksum = calculate_checksum(chunk_data)
   
   # Формирование JSON-объекта для отправки
   chunk_message = {
       "type": "file_chunk",
       "data": base64.b64encode(chunk_data).decode(),  # Данные в base64
       "checksum": chunk_checksum,                     # Контрольная сумма SHA-256
       "chunk_number": chunk_number,                   # Номер чанка
       "progress": progress                            # Прогресс передачи
   }
   
   # Сериализация в JSON
   json_data = json.dumps(chunk_message)
```
2. Шифрование (если передача через прокси):
```python
   if cipher:
       encrypted_data = cipher.encrypt(json_data.encode())
```
3. Отправка данных через UDP-сокет
```python
   sock.sendto(encrypted_data, target_address)
```
## На стороне получателя:

1. Получение данных:
```python
#Apply to utils.py
data, addr = sock.recvfrom(buffer_size)
``` 

2. Расшифровка (если данные зашифрованы):
 ```python
#Apply to utils.py
if cipher:
      data = cipher.decrypt(data)
```

3. Десериализация из JSON:
```python
   #Apply to utils.py
   request = json.loads(data.decode())
   chunk_data = base64.b64decode(request["data"])
   received_checksum = request["checksum"]
```

4. Проверка контрольной суммы:
  ``` python
   Apply to utils.py
   if not verify_checksum(chunk_data, received_checksum):
     # Ошибка целостности данных
      raise FileTransferError("Ошибка контрольной суммы")
```

Контрольная сумма не "встраивается" в сами данные, а передается как отдельное поле в структуре сообщения. Это позволяет:

1. Не изменять исходные данные
2. Легко выполнять проверку целостности
3. Использовать единый формат сообщений для разных типов данных

Для каждого чанка файла отправляется JSON-объект, содержащий:

- Тип сообщения (file_chunk)
- Сами данные в base64-кодировке
- Контрольную сумму (SHA-256 хеш)
- Дополнительную информацию (номер чанка, прогресс и т.д.)

Такой подход обеспечивает надежную проверку целостности каждого фрагмента передаваемого файла.