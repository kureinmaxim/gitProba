# Шифрование в ProxyCrypto (Прокси <-> Сервер)

Этот документ подробно описывает механизм шифрования, используемый для защиты данных при передаче между Прокси (`proxyCrypto.py`) и Сервером (`serverCrypto.py`/`serverCrypto_local.py`).

## Обзор используемого шифрования: Fernet

В системе ProxyCrypto используется **Fernet** из библиотеки `cryptography` Python.

### Что такое Fernet?

Fernet — это стандарт симметричного шифрования (один и тот же ключ для шифрования и расшифрования), который гарантирует, что зашифрованное сообщение не может быть подделано или прочитано без ключа. Он использует:

1.  **AES-128 в режиме CBC** для шифрования.
2.  **HMAC с SHA256** для аутентификации (проверки целостности и подлинности сообщения).
3.  **PKCS7** для дополнения (padding) данных до нужного размера блока AES.

Ключ Fernet инкапсулирует в себе как ключ шифрования AES, так и ключ аутентификации HMAC.

### Ключевые особенности Fernet

*   **Симметричность:** Один ключ для шифрования и расшифрования.
*   **Аутентификация (AE - Authenticated Encryption):** Fernet не только шифрует, но и подписывает сообщение с помощью HMAC. При расшифровании подпись проверяется. Если данные были изменены после шифрования, или использован неверный ключ, расшифрование не удастся (возникнет исключение `InvalidToken`). Это защищает от атак на изменение передаваемых данных (tampering).
*   **Версионирование:** Токены Fernet содержат версию формата, что позволяет обновлять алгоритмы в будущем без потери совместимости со старыми токенами (хотя в текущей реализации это не используется активно).
*   **Кодирование Base64:** Зашифрованные токены Fernet кодируются в URL-safe Base64, что делает их удобными для передачи в текстовых протоколах или как часть JSON.

### Как генерируется ключ?

Ключ Fernet — это 32-байтная строка, закодированная в URL-safe Base64. Он генерируется случайным образом и должен храниться в секрете.

```python
from cryptography.fernet import Fernet

# Генерация нового ключа
key = Fernet.generate_key()
print(f"Сгенерированный ключ (bytes): {key}")
print(f"Сгенерированный ключ (string): {key.decode()}")
# Пример вывода: b'V1Q4dnRvH-2wdZpERkbW4GdpeX_vdfbWHGHiw_6sx18='
```

**Важно:** Один и тот же ключ должен использоваться и на прокси, и на сервере. Его необходимо безопасно передать и сохранить на обеих сторонах.

### Процесс шифрования

1.  Создается экземпляр `Fernet` с секретным ключом.
2.  Исходные данные (например, JSON-строка или байты файла) **обязательно** преобразуются в `bytes`. Для текста обычно используется кодировка UTF-8.
3.  Вызывается метод `fernet.encrypt(data_bytes)`.
4.  Результат — зашифрованный токен (объект `bytes`), закодированный в URL-safe Base64.

### Процесс расшифрования

1.  Создается экземпляр `Fernet` с **тем же самым** секретным ключом.
2.  Полученный зашифрованный токен (объект `bytes`) передается в метод `fernet.decrypt(encrypted_token_bytes)`.
3.  Fernet сначала проверяет подлинность и целостность токена с помощью HMAC и временной метки (TTL - Time-To-Live, по умолчанию не ограничен). Если проверка не проходит (неверный ключ, данные изменены), генерируется исключение `cryptography.fernet.InvalidToken`.
4.  Если проверка успешна, данные расшифровываются с помощью AES.
5.  Результат — исходные данные в виде объекта `bytes`.
6.  Эти байты затем декодируются обратно в нужный формат (например, текст UTF-8).

## Примеры шифрования/расшифрования

```python
from cryptography.fernet import Fernet
import os # Для примера с бинарными данными

# 0. Генерируем или используем существующий ключ
# Используем ключ из примера генерации выше для согласованности
key = b'V1Q4dnRvH-2wdZpERkbW4GdpeX_vdfbWHGHiw_6sx18='

# 1. Создаем объект Fernet
fernet = Fernet(key)

# --- Пример 1: Шифрование текстового сообщения (ASCII/UTF-8) --- 
print("\n--- Пример 1: Текст ---")
message = "Привет, мир! Это тестовое сообщение с кириллицей."
print(f"Исходное сообщение: {message}")

# 2. Кодируем сообщение в байты (UTF-8)
message_bytes = message.encode('utf-8')
print(f"Сообщение в байтах: {message_bytes}")

# 3. Шифруем байты
encrypted_message = fernet.encrypt(message_bytes)
print(f"Зашифрованный токен: {encrypted_message}")

# --- Процесс расшифрования --- 
print("\n--- Расшифрование текста ---")

# 4. Расшифровываем токен
decrypted_bytes = fernet.decrypt(encrypted_message)
print(f"Расшифрованные байты: {decrypted_bytes}")

# 5. Декодируем байты обратно в строку UTF-8
original_message = decrypted_bytes.decode('utf-8')
print(f"Исходное сообщение: {original_message}")

# 6. Проверка
assert message == original_message
print("Проверка текста: Успешно!")


# --- Пример 2: Шифрование бинарных данных (фрагмент файла) --- 
print("\n--- Пример 2: Бинарные данные ---")

# Создаем немного бинарных данных (например, первые 50 байт случайных данных)
# В реальном приложении это будут байты чанка файла
binary_data = os.urandom(50)
print(f"Исходные бинарные данные: {binary_data}")

# 2. Бинарные данные уже являются байтами, кодировать не нужно.

# 3. Шифруем байты
encrypted_binary = fernet.encrypt(binary_data)
print(f"Зашифрованный бинарный токен: {encrypted_binary}")

# --- Процесс расшифрования --- 
print("\n--- Расшифрование бинарных данных ---")

# 4. Расшифровываем токен
decrypted_binary_bytes = fernet.decrypt(encrypted_binary)
print(f"Расшифрованные бинарные байты: {decrypted_binary_bytes}")

# 5. Декодировать не нужно, результат уже бинарный.

# 6. Проверка
assert binary_data == decrypted_binary_bytes
print("Проверка бинарных данных: Успешно!")

# --- Пример ошибки: Неверный ключ или токен --- 
print("\n--- Пример ошибки ---")
try:
    # Генерируем другой ключ
    wrong_key = Fernet.generate_key()
    wrong_fernet = Fernet(wrong_key)
    
    # Пытаемся расшифровать сообщение, зашифрованное первым ключом
    wrong_fernet.decrypt(encrypted_message)
except Exception as e:
    print(f"Ожидаемая ошибка при неверном ключе: {type(e).__name__} - {e}")

try:
    # Пытаемся расшифровать "испорченный" токен (добавим байт в конец)
    tampered_token = encrypted_message + b'x'
    fernet.decrypt(tampered_token)
except Exception as e:
    print(f"Ожидаемая ошибка при испорченном токене: {type(e).__name__} - {e}")

```

## Альтернативные методы шифрования для приложения

Хотя Fernet предоставляет хороший базовый уровень безопасности (аутентифицированное шифрование), существуют и другие подходы, часто используемые для защиты сетевого трафика:

### 1. TLS/SSL (Transport Layer Security)

Это стандарт де-факто для защиты TCP-соединений (например, HTTPS). Хотя наше приложение использует UDP, существуют реализации TLS поверх UDP (DTLS - Datagram TLS).

*   **Принцип:** Устанавливает защищенный канал между двумя точками. Включает аутентификацию сторон (обычно сервера, через сертификаты), согласование сеансового ключа (с использованием асимметричной криптографии, например RSA или ECC) и шифрование трафика (с использованием симметричных шифров, таких как AES-GCM или ChaCha20-Poly1305).
*   **Плюсы:**
    *   Высокая степень защиты и стандартизации.
    *   Автоматически решает проблемы управления ключами и их обмена.
    *   Обеспечивает **совершенную прямую секретность (PFS - Perfect Forward Secrecy)**: компрометация долгосрочного ключа сервера не позволяет расшифровать прошлые сеансы.
    *   Аутентификация сервера (и опционально клиента) с помощью сертификатов.
*   **Минусы:**
    *   Более сложная настройка (генерация/получение сертификатов, настройка сервера и клиента).
    *   DTLS может быть сложнее в реализации и иметь больший оверхед по сравнению с простым симметричным шифрованием поверх UDP.
    *   Требует использования специализированных библиотек (`ssl`, `pyOpenSSL`).

### 2. AES-GCM (Galois/Counter Mode)

Это современный режим работы для блочного шифра AES, обеспечивающий аутентифицированное шифрование с присоединенными данными (AEAD).

*   **Принцип:** Использует AES для шифрования и одновременно вычисляет тег аутентификации (MAC). Считается более эффективным и безопасным, чем многие старые режимы (например, CBC+HMAC, который лежит в основе Fernet).
*   **Плюсы:**
    *   Высокая производительность (особенно при наличии аппаратной поддержки AES).
    *   Сильные гарантии безопасности (при правильном использовании).
    *   Широко используется (в т.ч. в TLS 1.2 и 1.3).
    *   Поддерживается библиотекой `cryptography`.
*   **Минусы:**
    *   **Критически важно правильное управление nonce (Initialization Vector - IV):** Nonce *никогда* не должен повторяться для одного и того же ключа. Повторное использование nonce может полностью скомпрометировать шифрование.
    *   Требует безопасного механизма обмена ключами (как и Fernet).
    *   Не предоставляет PFS сам по себе.

### 3. ChaCha20-Poly1305

Еще один современный алгоритм AEAD, альтернатива AES-GCM.

*   **Принцип:** Потоковый шифр ChaCha20 в сочетании с кодом аутентификации сообщений Poly1305.
*   **Плюсы:**
    *   Очень высокая производительность, особенно на платформах без аппаратного ускорения AES (мобильные устройства, некоторые процессоры).
    *   Считается очень безопасным.
    *   Используется в TLS 1.3.
    *   Поддерживается библиотекой `cryptography`.
*   **Минусы:**
    *   Аналогично AES-GCM, **критически важно уникальное управление nonce** для каждого ключа.
    *   Требует безопасного механизма обмена ключами.
    *   Не предоставляет PFS сам по себе.

## Сравнение и устойчивость к взлому

*   **Fernet (AES-128-CBC + HMAC-SHA256):** Обеспечивает хороший базовый уровень защиты для многих приложений. AES-128 все еще считается надежным. HMAC-SHA256 обеспечивает сильную аутентификацию. Главное — безопасное хранение и передача ключа. Уязвим для атак на основе анализа трафика (длина сообщений и т.д.), как и другие симметричные шифры без дополнительных мер.

*   **AES-GCM / ChaCha20-Poly1305:** Считаются более современными и часто предпочтительными AEAD-режимами по сравнению с CBC+HMAC. Они потенциально быстрее и имеют лучшие свойства безопасности *при условии строгой уникальности nonce*. Ошибки в управлении nonce могут быть катастрофическими.

*   **TLS/DTLS:** Обеспечивает наиболее комплексную защиту для сетевого канала. Он не только шифрует и аутентифицирует данные, но и защищает процесс согласования ключей, аутентифицирует сервер (защита от MitM-атак при использовании доверенных сертификатов) и обеспечивает PFS. Это самый устойчивый к взлому вариант для **сетевого канала**, так как он решает множество проблем безопасности "из коробки".

**Устойчивость к взлому зависит не только от алгоритма, но и от:**

1.  **Длины и энтропии ключа:** Fernet использует AES-128, что на данный момент достаточно. Более длинные ключи (AES-256) теоретически устойчивее, но и медленнее.
2.  **Безопасности управления ключами:** Как ключи генерируются, хранятся и передаются — часто самое слабое звено.
3.  **Правильности реализации:** Ошибки в коде, особенно в управлении nonce для AES-GCM/ChaCha20, могут свести на нет всю криптографию.
4.  **Защиты конечных точек:** Если прокси или сервер скомпрометированы, шифрование канала не поможет.
5.  **Квантовые компьютеры (будущее):** Ожидается, что мощные квантовые компьютеры смогут взламывать современные асимметричные алгоритмы (RSA, ECC), используемые в TLS для обмена ключами. Симметричные шифры (AES, ChaCha20) считаются более устойчивыми (хотя может потребоваться удвоение длины ключа). Ведется разработка постквантовой криптографии.

## Заключение

Используемый в ProxyCrypto Fernet обеспечивает **аутентифицированное симметричное шифрование**, что является значительным шагом по сравнению с отсутствием шифрования. Он прост в использовании и достаточно надежен для базовой защиты канала прокси-сервер при условии безопасного управления ключом.

Для приложений, требующих максимальной защиты сетевого канала, отраслевым стандартом является **TLS (или DTLS для UDP)**. Он обеспечивает более полный набор функций безопасности, включая безопасный обмен ключами и аутентификацию сервера.

Прямое использование **AES-GCM** или **ChaCha20-Poly1305** также является сильной альтернативой, но требует от разработчика большей аккуратности в реализации, особенно в части управления nonce. 