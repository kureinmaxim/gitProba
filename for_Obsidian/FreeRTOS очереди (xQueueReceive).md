#freertos 
[[FreeRTOS]]
#### **Очереди (`xQueueReceive`)**

Очереди позволяют задачам передавать данные друг другу. Если задача пытается получить данные из пустой очереди, она может:

- Либо немедленно вернуться с ошибкой.
- Либо войти в состояние ожидания на определенное время, ожидая появления новых данных.

##### **Пример работы `xQueueReceive`:**
```c
QueueHandle_t myQueue = xQueueCreate(5, sizeof(int)); // Создаем очередь для хранения 5 целых чисел

void task1(void *args) {
    int data = 42;
    while (1) {
        xQueueSend(myQueue, &data, portMAX_DELAY);  // Отправляем данные
        vTaskDelay(pdMS_TO_TICKS(1000));            // Задержка 1 секунда
    }
}

void task2(void *args) {
    int receivedData;
    while (1) {
        // Ожидаем данные из очереди максимум 500 мс
        if (xQueueReceive(myQueue, &receivedData, pdMS_TO_TICKS(500))) {
            // Успешно получили данные
            uart_putc('R');
        } else {
            // Таймаут - данные не пришли
            uart_putc('T');
        }
    }
}
```
##### **Механизм работы:**

- Если `xQueueReceive()` вызывается, но очередь пуста, задача блокируется (переходит в состояние **Blocked**) на указанный таймаут (`pdMS_TO_TICKS(500)`).
- Если за это время данные появляются, задача переходит в состояние **Ready** и получает управление.
- Если данные не появляются, задача просто продолжит выполнение после истечения таймера.
##### **Что происходит на уровне планировщика**

1. Когда задача блокируется из-за вызова `xQueueReceive()` или `xSemaphoreTake()`:
    - Планировщик освобождает процессор и переключает выполнение на другие задачи.
    - Если событие (получение данных или освобождение семафора) происходит, задача снова становится готовой (`Ready`).
2. Если указан таймаут, задача просто переходит в состояние **Ready** по истечении этого времени, даже если данные не поступили или семафор не освободился.

---

##### **Резюме**

Эти функции (`xQueueReceive`, `xSemaphoreTake`) позволяют задачам эффективно ждать необходимых событий, освобождая процессорное время для других задач, что критично для систем реального времени.