#stm  #freertos 

Структурированный Алгоритм Проекта (STM32 + FreeRTOS)

**1. Конфигурация в STM32CubeIDE (используя перспективу CubeMX):**

- Выбор МК: Убедитесь, что выбран правильный микроконтроллер.
- Тактирование: Настройте систему тактирования (RCC), включая HSE/HSI, PLL, и частоты системной шины (AHB, APB1, APB2).
- Периферия: Включите и настройте всю необходимую периферию:
- GPIO: Конфигурация пинов (вход/выход, подтяжки, скорость, альтернативные функции).
- Коммуникационные интерфейсы: UART, SPI, I2C и т.д. (режим работы, скорость, прерывания, DMA).
- АЦП/ЦАП: Каналы, разрешение, режим сканирования, прерывания, DMA.
- Таймеры: Режим работы (счет, ШИМ, захват), предделители, периоды, прерывания, DMA.
- Middleware:
- FreeRTOS:
- Включите FreeRTOS (интерфейс CMSIS\V1 или CMSIS\_V2 рекомендуется для лучшей интеграции с CubeIDE).
- Настройте параметры: размер кучи (TOTAL_HEAP_SIZE), частоту тика (configTICK_RATE_HZ), максимальные приоритеты, проверку переполнения стека (configCHECK_FOR_STACK_OVERFLOW) и т.д.
- Опционально: Определите задачи, очереди, семафоры, мьютексы и таймеры прямо в конфигураторе CubeMX. Это сгенерирует код для их создания.
- Другие Middleware: Добавьте и настройте FATFS, LwIP, USB и т.п., если они нужны.
- DMA: Настройте каналы DMA для периферии, где это необходимо (например, UART, SPI, ADC), чтобы разгрузить ЦПУ.
- NVIC (Прерывания):
- Включите необходимые прерывания для периферии и DMA.
- Важно: Установите приоритеты прерываний. Прерывания, вызывающие функции API FreeRTOS (...FromISR), должны иметь логический приоритет ниже или равный configMAX_SYSCALL_INTERRUPT_PRIORITY (обратите внимание, что на ARM Cortex-M численно меньшее значение означает более высокий приоритет). Прерывания с более высоким приоритетом не смогут вызывать API FreeRTOS.
- Генерация Кода: Сгенерируйте код инициализации проекта (Project -> Generate Code).

**2. Инициализация в main.c:**

- Сгенерированный main() уже будет содержать основные вызовы:
- HAL_Init(): Инициализация HAL.
- SystemClock_Config(): Настройка тактирования (сгенерирована).
- MX_GPIO_Init(), MX_USART1_UART_Init(), MX_TIM2_Init() и т.д.: Инициализация периферии (сгенерированы).
- MX_DMA_Init(): Инициализация DMA (сгенерирована).
- MX_FREERTOS_Init(): Инициализация FreeRTOS, включая создание объектов (задач, очередей и т.д.), определенных в CubeMX (сгенерирована в freertos.c).
- Дополнительная инициализация: Добавьте сюда любой код инициализации вашего приложения, который должен выполниться перед запуском планировщика FreeRTOS, но после инициализации периферии и RTOS (например, чтение конфигурации из EEPROM, калибровка сенсоров).

**3. Определение и Создание Задач FreeRTOS:**
- Метод 1 (CubeMX): Задачи, определенные в конфигураторе, создаются автоматически в MX_FREERTOS_Init(). Их функции-обработчики (например, StartDefaultTask) будут сгенерированы в freertos.c.
- Метод 2 (Вручную): Если вы не определяли задачи в CubeMX или вам нужно создать их динамически, используйте osThreadNew() (CMSIS API) или xTaskCreate() (Native API) в main.c перед osKernelStart() или внутри других задач.
- Для каждой задачи необходимо определить:
- Функцию задачи (указатель на функцию).
- Имя (для отладки).
- Размер стека (критически важный параметр, подбирается!).
- Параметр, передаваемый в задачу (void\*).
- Приоритет.
- Атрибуты (для CMSIS API).

**4. Реализация Функций Задач:**

- Каждая функция задачи должна содержать бесконечный цикл (for(;;)).
- Внутри цикла:
- Выполняйте основную логику задачи (опрос датчиков, управление моторами, обмен данными по UART и т.д.).
- Используйте блокирующие вызовы FreeRTOS для ожидания событий или для передачи управления:
- osDelay() / vTaskDelay(): Пауза на заданное количество тиков.
- osMessageQueueGet() / xQueueReceive(): Ожидание данных в очереди.
- osSemaphoreAcquire() / xSemaphoreTake(): Ожидание семафора или мьютекса.
- ulTaskNotifyTake(): Ожидание уведомления задачи.
- Никогда не используйте активное ожидание (пустые циклы while(...) {} или HAL_Delay()) внутри задач, так как это блокирует выполнение других задач с тем же или более низким приоритетом.

**5. Межзадачное Взаимодействие и Синхронизация:**

- Очереди (osMessageQueue / Queue): Для безопасной передачи данных между задачами или из прерываний в задачи.
- Семафоры (osSemaphore / Semaphore): Для сигнализации о событиях (бинарные) или управления доступом к ограниченному числу ресурсов (счетные).
- Мьютексы (osMutex / Mutex): Для защиты разделяемых ресурсов (переменные, периферия) от одновременного доступа из разных задач (проблема гонок данных). Используйте мьютексы с приоритетным наследованием (если включено в конфигурации), чтобы избежать инверсии приоритетов.
- Уведомления Задач (osThreadFlagsSet/Wait / xTaskNotifyGive/Take): Легковесный и быстрый способ прямой сигнализации между одной задачей и другой или из прерывания в задачу.

**6. Обработка Прерываний (ISR):**

- Обработчики прерываний должны быть максимально короткими и быстрыми.
- Не вызывайте из ISR стандартные API FreeRTOS или HAL функции, которые могут блокировать выполнение.
- Используйте специальные ...FromISR версии API FreeRTOS для взаимодействия с задачами (например, osMessageQueuePut с ISR флагом / xQueueSendFromISR, osSemaphoreRelease с ISR флагом / xSemaphoreGiveFromISR, vTaskNotifyGiveFromISR).
- Основную обработку данных, полученных в прерывании, делегируйте соответствующей задаче FreeRTOS через очередь, семафор или уведомление.

**7 Запуск Планировщика FreeRTOS:**

- В конце функции main() вызывается osKernelStart() (CMSIS API) или vTaskStartScheduler() (Native API).
- Эта функция передает управление задачам FreeRTOS и никогда не возвращается (если запуск прошел успешно). Код после этого вызова в main() не выполняется.

**8. Отладка:**

- Используйте отладчик STM32CubeIDE (точки останова, просмотр переменных).
- Включите и используйте хуки FreeRTOS:
- vApplicationStackOverflowHook: Вызывается при переполнении стека задачи.
- vApplicationMallocFailedHook: Вызывается, если pvPortMalloc не смог выделить память (при создании объектов RTOS).
- vApplicationIdleHook: Вызывается в задаче Idle (можно использовать для измерения загрузки ЦПУ или перевода МК в режим сна).
- Используйте функции FreeRTOS для получения информации о состоянии системы (например, uxTaskGetStackHighWaterMark для контроля использования стека).
- Выводите отладочную информацию через UART или ITM/SWO.