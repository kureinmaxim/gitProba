# Анализ сетевого трафика ProxyCrypto

Этот документ описывает методы и инструменты для анализа сетевого взаимодействия между компонентами системы ProxyCrypto: Клиентом (`client.py`), Прокси (`proxyCrypto.py`) и Сервером (`serverCrypto.py` или `serverCrypto_local.py`).

## Обзор взаимодействия

- **Клиент <-> Прокси (Локально):**
    - **Протокол:** UDP
    - **Порт по умолчанию:** 9999 (слушает прокси)
    - **Шифрование:** **НЕТ**
    - **Данные:** JSON-сообщения в текстовом виде.
    - **Интерфейс:** Loopback (`lo0` на macOS, `lo` на Linux).

- **Прокси <-> Сервер (Локально или Удаленно):**
    - **Протокол:** UDP
    - **Порт по умолчанию:** 8888 (слушает сервер)
    - **Шифрование:** **ДА** (Fernet)
    - **Данные:** Зашифрованные байтовые строки.
    - **Интерфейс:**
        - Локально: Loopback (`lo0` / `lo`).
        - Удаленно: Основной сетевой интерфейс (`en0`, `eth0`, etc.)

## Инструменты для анализа

Мы рассмотрим три основных инструмента:

1.  **tcpdump:** Классическая утилита командной строки для захвата пакетов. Мощная, но вывод может быть менее читаемым для протоколов высокого уровня.
2.  **Wireshark (и tshark):** Мощный графический (Wireshark) и консольный (tshark) анализатор протоколов. Отлично подходит для детального разбора и фильтрации.
3.  **ngrep:** Утилита, похожая на `grep`, но для сетевого трафика. Удобна для быстрого поиска текстовых строк в полезной нагрузке пакетов.

### Установка инструментов

- **tcpdump:** Обычно предустановлен в macOS и большинстве дистрибутивов Linux.
- **Wireshark / tshark:**
    - **macOS (Homebrew):** `brew install wireshark`
    - **Linux (Debian/Ubuntu):** `sudo apt update && sudo apt install tshark wireshark jq` (jq понадобится для tshark)
    - **Linux (Fedora/CentOS):** `sudo dnf install wireshark-cli wireshark-qt jq`
    *Во время установки `tshark` может спросить о разрешении захвата для не-root пользователей. Это удобно, но для loopback-интерфейса (`lo`/`lo0`) часто все равно требуется `sudo`.*
- **ngrep:**
    - **macOS (Homebrew):** `brew install ngrep`
    - **Linux (Debian/Ubuntu):** `sudo apt install ngrep`
    - **Linux (Fedora/CentOS):** `sudo dnf install ngrep`

---

## 1. Анализ трафика: Клиент <-> Прокси (Локально, Нешифрованный)

Этот трафик наиболее интересен для отладки логики сообщений, так как он не зашифрован.

### 1.1. Использование `tcpdump`

Простой способ быстро увидеть обмен пакетами.

**Команда:**

```bash
# macOS
sudo tcpdump -i lo0 -A udp port 9999

# Linux
sudo tcpdump -i lo -A udp port 9999
```

**Плюсы:**
*   Простота и доступность.

**Минусы:**
*   Вывод флага `-A` может смешивать заголовки и данные.
*   Плохо читает JSON и Unicode (показывает экранированные последовательности).

### 1.2. Использование `tshark` + `jq` (Рекомендуется для JSON)

Гораздо удобнее для просмотра JSON-сообщений.

**Команда:**
```bash
# ==macOS / Linux==
sudo tshark -l -i lo0 -Y 'udp.port == 9999' -T fields -e data | while read hex_line; do echo "$hex_line" | xxd -r -p | jq '.'; done
# Примечание: Для Linux замените lo0 на lo, если это ваш loopback интерфейс
```
**Как это работает:**
1.  `sudo tshark -l -i lo0 -Y 'udp.port == 9999' -T fields -e data`: Захватывает пакеты на loopback-интерфейсе (порт 9999) и для каждого пакета выводит его полезную нагрузку в виде строки шестнадцатеричных символов (hex).
2.  `| while read hex_line; do ... ; done`: Перенаправляет вывод `tshark` в цикл `while`, который обрабатывает каждую полученную hex-строку отдельно.
3.  `echo "$hex_line" | xxd -r -p`: Каждая hex-строка (`hex_line`) передается в `xxd`, который декодирует ее обратно в исходные байты (текст JSON).
4.  `| jq '.'`: Декодированные байты (являющиеся JSON-строкой) передаются в `jq` для красивого форматирования.

==Для Windows 11==
- Установить Wireshark (и tshark.exe вместе с ним) устанавливается в C:\Program Files\Wireshark\.
- Настройки Системных переменных среды. В  окне "Переменные среды" найди раздел "Системные переменные" (System variables) . В списке системных переменных найди переменную с именем Path (или PATH). Выдели строку с Path и нажми кнопку "Изменить..." (Edit...). - Вставить скопированный на шаге 1 путь к директории Wireshark (например, C:\Program Files\Wireshark). Это добавит tshark.exe в системную переменную PATH в Windows 11.
- Проверка в новом окне Powershell
```powershell
tshark -v
OR
where tshark
```
- Установить  ==jq==  -> через Chocolatey:
в PowerShell от имени Администратора
```powershell
 choco install jq    # Chocolatey установит jq и позаботится о PATH.
```
- Проверка в новом окне Powershell
```powershell
jq --version 
OR
where jq
```
- Создать файла скрипта в любом текстовом редакторе
- Сохранить его с расширением .ps1. Например,  monitor_udp_json.ps1. Сохранить в например, в папку проекта.
```powershell
# 1. Узнай имя/номер loopback интерфейса: tshark -D
# 2. Замени <LoopbackInterface> на правильное значение.
# 3. Установи jq и убедись, что он в PATH.
# 4. Запускай эту команду в PowerShell от имени Администратора.

# --- Начало скрипта ---
Write-Host "Запуск мониторинга UDP порта 9999 на loopback интерфейсе..."
Write-Host "Для остановки нажмите Ctrl+C"

# !!! ВАЖНО: Замените <LoopbackInterface> ниже на реальный номер или имя !!!
# !!!      (полученное из вывода команды 'tshark -D')                !!!
# $loopbackInterface = "<LoopbackInterface>"
$loopbackInterface = "\Device\NPF_Loopback"
$udpPort = 9999

# Проверяем, что tshark доступен
if (-not (Get-Command tshark.exe -ErrorAction SilentlyContinue)) {
    Write-Error "Команда tshark.exe не найдена. Убедитесь, что Wireshark установлен и его директория добавлена в PATH."
    exit 1 # Выходим из скрипта
}

# Проверяем, что jq доступен
if (-not (Get-Command jq -ErrorAction SilentlyContinue)) {
    Write-Error "Команда jq не найдена. Убедитесь, что jq установлен и доступен в PATH."
    exit 1 # Выходим из скрипта
}

# Проверяем, что интерфейс был указан
if ($loopbackInterface -eq "<LoopbackInterface>") {
     Write-Error "Необходимо указать правильный loopback интерфейс в переменной `$loopbackInterface внутри скрипта. Запустите 'tshark -D' для его определения."
     exit 1
}


Write-Host "Используется интерфейс: $loopbackInterface"
Write-Host "Прослушивается порт: $udpPort"
Write-Host "--- Начало вывода данных ---"

# Основная команда
try {
    tshark.exe -i $loopbackInterface -l -Y "udp.port == $udpPort" -T fields -e data | ForEach-Object {
        $hexString = $_.Trim()

        if ($hexString.Length -gt 0 -and $hexString -match '^[0-9a-fA-F]+$') {
            try {
                # Конвертируем HEX в байты
                $bytes = [System.Convert]::FromHexString($hexString)
                # Конвертируем байты в строку (предполагаем UTF-8)
                $text = [System.Text.Encoding]::UTF8.GetString($bytes)

                # Передаем содержимое переменной $text на стандартный ввод jq.exe
                $text | jq.exe '.'

            } catch [System.FormatException] {
                 Write-Warning "Пропущена невалидная hex-строка: $hexString"
            } catch [System.ArgumentException] {
                 Write-Warning "Пропущена невалидная hex-строка (нечетная длина?): $hexString"
            } catch {
                 # Эта ошибка теперь будет ловить проблемы при выполнении jq или если $text невалиден для jq
                 Write-Warning "Ошибка обработки строки '$hexString' или выполнения jq: $($_.Exception.Message)"
                 # Если хочешь видеть не-JSON данные, раскомментируй строку ниже:
                 # Write-Host "Необработанные данные для jq: $text"
            }
        } elseif ($hexString.Length -gt 0) {
             # Строка не пустая, но не является валидным hex
             Write-Warning "Пропущена строка, не содержащая только hex символы: $hexString"
        }
        # Пустые строки просто игнорируются
    }
} finally {
     Write-Host "--- Мониторинг остановлен ---"
}
# --- Конец скрипта ---
```
-  Разрешение на запуск скриптов (Execution Policy):
По умолчанию PowerShell может блокировать выполнение локально созданных скриптов. Открыть PowerShell от имени администратора. Проверить текущую политику: Get-ExecutionPolicy. Если политика Restricted (или AllSigned), ее изменить.
```powershell
        Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
- Перейти в директорию, где ты  файл monitor_udp_json.ps1.
```powershell
cd C:\Project\ProjectPython\ProxyCrypto
.\monitor_udp_json.ps1
```

**Плюсы:**
*   Чистый вывод отформатированных JSON-данных.
*   Корректное отображение Unicode (кириллица и т.д.).
*   Более надежно работает с потоковым выводом `tshark`, чем прямая передача в `jq`.

**Минусы:**
*   Требует установки `tshark`, `jq` и `xxd` (обычно `xxd` предустановлен).
*   Команда немного сложнее, чем простой `tcpdump`.


### 1.3. Использование `ngrep` (Для поиска строк)

Удобно, если вы хотите быстро найти пакеты, содержащие определенное слово или часть сообщения.

**Команда:**

```bash
# Найти пакеты с текстом "message_response" на порту 9999 (регистронезависимо)
# macOS
sudo ngrep -iq 'message_response' -d lo0 udp port 9999

# Linux
sudo ngrep -iq 'message_response' -d lo udp port 9999

# Найти пакеты с текстом "error"
# macOS
sudo ngrep -iq 'error' -d lo0 udp port 9999

# Linux
sudo ngrep -iq 'error' -d lo udp port 9999
```
*   `-i`: Игнорировать регистр.
*   `-q`: Тихий режим (меньше лишней информации).
*   `'паттерн'`: Текст или регулярное выражение для поиска.
*   `-d <интерфейс>`: Интерфейс для прослушивания.
*   `udp port 9999`: BPF-фильтр (как в tcpdump) для ограничения поиска.

**Плюсы:**
*   Быстрый поиск по содержимому.
*   Поддержка регулярных выражений.

**Минусы:**
*   Не форматирует JSON.

### 1.4. Использование Wireshark (Графический интерфейс)

Самый мощный инструмент для глубокого анализа.

**Как использовать:**

1.  **Запустите Wireshark** (может потребоваться `sudo wireshark` или настройка прав доступа для захвата).
2.  **Выберите интерфейс:** На главном экране дважды щелкните по интерфейсу `Loopback: lo0` (macOS) или `lo` (Linux). Начнется захват пакетов.
3.  **Примените фильтр отображения:** В строке "Apply a display filter..." введите:
    ```
    udp.port == 9999
    ```
    Нажмите Enter. Теперь будут отображаться только пакеты, идущие на/с порта 9999.
4.  **Воспроизведите трафик:** Запустите клиент и прокси, отправьте сообщение или файл.
5.  **Анализируйте пакеты:**
    *   **Список пакетов:** Верхняя панель показывает список захваченных пакетов. Выберите интересующий пакет.
    *   **Детали пакета:** Средняя панель показывает разобранные уровни протоколов (Frame, Loopback, IP, UDP, Data). Раскройте `User Datagram Protocol` и `Data`. Wireshark попытается показать данные как текст (`Data: ...`).
    *   **Байты пакета:** Нижняя панель показывает сырые байты пакета в HEX и ASCII.
6.  **Дополнительные возможности Wireshark:**
    *   **Follow UDP Stream:** Щелкните правой кнопкой мыши по пакету и выберите `Follow > UDP Stream`. Wireshark покажет все данные, переданные в рамках этого UDP-потока (между конкретной парой IP:Port <-> IP:Port) в отдельном окне, что удобно для просмотра диалога.
    *   **Фильтрация по JSON:** Если данные являются валидным JSON, Wireshark (в более новых версиях) может позволить фильтровать по полям JSON. Попробуйте фильтр вроде `json.value.string == "message_response"` (синтаксис может меняться).
    *   **Статистика:** Меню `Statistics` предлагает множество инструментов для анализа трафика (потоки, длины пакетов и т.д.).
7.  **Остановите захват:** Нажмите красную квадратную кнопку "Stop" на панели инструментов.
8.  **Сохраните захват (опционально):** `File > Save As...` для последующего анализа.

**Плюсы:**
*   Визуальный интерфейс.
*   Детальный разбор протоколов.
*   Мощные возможности фильтрации и анализа.
*   Функция "Follow Stream".

**Минусы:**
*   Требует графической среды.
*   Может быть избыточным для простого просмотра сообщений.

---

## 2. Анализ трафика: Прокси <-> Сервер (Зашифрованный)

Этот трафик зашифрован с помощью Fernet, поэтому вы **не сможете** прочитать исходные JSON-сообщения напрямую с помощью стандартных инструментов. Однако анализ этого трафика может быть полезен для:

*   **Диагностики проблем соединения:** Увидеть, доходят ли вообще пакеты до сервера/прокси.
*   **Анализа объемов трафика:** Оценить размер передаваемых зашифрованных данных.
*   **Проверки правильности IP/Портов:** Убедиться, что пакеты уходят на нужный адрес и порт.

### 2.1. Захват на локальной машине (трафик к удаленному серверу)

Нужно слушать основной сетевой интерфейс и фильтровать по IP-адресу **удаленного сервера** и порту **сервера** (по умолч. 8888).

**Нахождение имени интерфейса:**

*   **macOS:** `ifconfig` (ищите интерфейс с вашим IP, часто `en0` или `enX`)
*   **Linux:** `ip addr` или `ifconfig` (ищите интерфейс с вашим IP, часто `eth0`, `ensX`)

**Команды (замените `<интерфейс>`, `<IP_СЕРВЕРА>`):**

*   **`tcpdump`:**
    ```bash
    sudo tcpdump -i <интерфейс> -nvv udp and host <IP_СЕРВЕРА> and port 8888
    ```
    *   `-n`: Не преобразовывать IP/порты в имена.
    *   `-vv`: Более подробный вывод (но не `-A`, так как данные бинарные).
*   **`tshark`:**
    ```bash
    sudo tshark -l -i <интерфейс> -Y "udp.port == 8888 && ip.addr == <IP_СЕРВЕРА>"
    ```
*   **`ngrep` (менее полезен, т.к. данные зашифрованы):**
    ```bash
    # Просто смотрим пакеты на порт 8888
    sudo ngrep -d <интерфейс> '' udp and host <IP_СЕРВЕРА> and port 8888
    ```
*   **Wireshark:**
    1.  Запустите Wireshark.
    2.  Выберите основной сетевой интерфейс (`en0`, `eth0`...).
    3.  Примените фильтр отображения: `udp.port == 8888 && ip.addr == <IP_СЕРВЕРА>`
    4.  Анализируйте поток пакетов (размеры, частоту), но содержимое поля `Data` будет нечитаемым шифротекстом.

### 2.2. Захват на удаленном сервере

Аналогично захвату на локальной машине, но команды выполняются на VDS через SSH. Слушать нужно порт сервера (8888) и фильтровать по IP-адресу **вашего локального компьютера** (или IP, с которого подключается прокси).

**Команды (замените `<интерфейс_сервера>`, `<IP_ПРОКСИ>`):**

*   **`tcpdump`:**
    ```bash
    sudo tcpdump -i <интерфейс_сервера> -nvv udp and host <IP_ПРОКСИ> and port 8888
    ```
*   **`tshark`:**
    ```bash
    sudo tshark -l -i <интерфейс_сервера> -Y "udp.port == 8888 && ip.addr == <IP_ПРОКСИ>"
    ```

---

**Заключение:**

*   Для отладки **логики сообщений** используйте анализ трафика **Клиент <-> Прокси** с помощью `tshark+jq` или Wireshark.
*   Для отладки **проблем соединения** или анализа **объемов шифрованного трафика** используйте анализ трафика **Прокси <-> Сервер** с помощью `tcpdump` или Wireshark, обращая внимание на наличие пакетов, их направление и адресацию.
*   `ngrep` удобен для быстрого поиска текстовых фрагментов в **незашифрованном** трафике Клиент <-> Прокси.

